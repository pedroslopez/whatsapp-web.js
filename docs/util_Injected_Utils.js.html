<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.6.11">
  <meta charset="utf-8">
  <title>whatsapp-web.js 1.26.1-alpha.2 &raquo; Source: util/Injected/Utils.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">whatsapp-web.<wbr>js 1.<wbr>26.<wbr>1-alpha.<wbr>2</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: util/Injected/Utils.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>&#x27;use strict&#x27;;

exports.LoadUtils &#x3D; () &#x3D;&gt; {
    window.WWebJS &#x3D; {};

    window.WWebJS.forwardMessage &#x3D; async (chatId, msgId) &#x3D;&gt; {
        const msg &#x3D; window.Store.Msg.get(msgId) || (await window.Store.Msg.getMessagesById([msgId]))?.messages?.[0];
        let chat &#x3D; window.Store.Chat.get(chatId);

        if (window.compareWwebVersions(window.Debug.VERSION, &#x27;&gt;&#x27;, &#x27;2.3000.0&#x27;)) {
            return window.Store.ForwardUtils.forwardMessagesToChats([msg], [chat], false);
        } else {
            return chat.forwardMessages([msg]);
        }
    };

    window.WWebJS.sendSeen &#x3D; async (chatId) &#x3D;&gt; {
        let chat &#x3D; window.Store.Chat.get(chatId);
        if (chat !&#x3D;&#x3D; undefined) {
            await window.Store.SendSeen.sendSeen(chat, false);
            return true;
        }
        return false;

    };

    window.WWebJS.sendMessage &#x3D; async (chat, content, options &#x3D; {}) &#x3D;&gt; {
        let attOptions &#x3D; {};
        if (options.attachment) {
            attOptions &#x3D; options.sendMediaAsSticker
                ? await window.WWebJS.processStickerData(options.attachment)
                : await window.WWebJS.processMediaData(options.attachment, {
                    forceVoice: options.sendAudioAsVoice,
                    forceDocument: options.sendMediaAsDocument,
                    forceGif: options.sendVideoAsGif
                });
            
            attOptions.caption &#x3D; options.caption;
            content &#x3D; options.sendMediaAsSticker ? undefined : attOptions.preview;
            attOptions.isViewOnce &#x3D; options.isViewOnce;

            delete options.attachment;
            delete options.sendMediaAsSticker;
        }
        let quotedMsgOptions &#x3D; {};
        if (options.quotedMessageId) {
            let quotedMessage &#x3D; await window.Store.Msg.getMessagesById([options.quotedMessageId]);

            if (quotedMessage[&#x27;messages&#x27;].length !&#x3D; 1) {
                throw new Error(&#x27;Could not get the quoted message.&#x27;);
            }

            quotedMessage &#x3D; quotedMessage[&#x27;messages&#x27;][0];

            // TODO remove .canReply() once all clients are updated to &gt;&#x3D; v2.2241.6
            const canReply &#x3D; window.Store.ReplyUtils ? 
                window.Store.ReplyUtils.canReplyMsg(quotedMessage.unsafe()) : 
                quotedMessage.canReply();

            if (canReply) {
                quotedMsgOptions &#x3D; quotedMessage.msgContextInfo(chat);
            }
            delete options.quotedMessageId;
        }

        if (options.mentionedJidList) {
            options.mentionedJidList &#x3D; await Promise.all(
                options.mentionedJidList.map(async (id) &#x3D;&gt; {
                    const wid &#x3D; window.Store.WidFactory.createWid(id);
                    if (await window.Store.QueryExist(wid)) {
                        return wid;
                    }
                })
            );
            options.mentionedJidList &#x3D; options.mentionedJidList.filter(Boolean);
        }

        if (options.groupMentions) {
            options.groupMentions &#x3D; options.groupMentions.map((e) &#x3D;&gt; ({
                groupSubject: e.subject,
                groupJid: window.Store.WidFactory.createWid(e.id)
            }));
        }

        let locationOptions &#x3D; {};
        if (options.location) {
            let { latitude, longitude, description, url } &#x3D; options.location;
            url &#x3D; window.Store.Validators.findLink(url)?.href;
            url &amp;amp;&amp;amp; !description &amp;amp;&amp;amp; (description &#x3D; url);
            locationOptions &#x3D; {
                type: &#x27;location&#x27;,
                loc: description,
                lat: latitude,
                lng: longitude,
                clientUrl: url
            };
            delete options.location;
        }

        let _pollOptions &#x3D; {};
        if (options.poll) {
            const { pollName, pollOptions } &#x3D; options.poll;
            const { allowMultipleAnswers, messageSecret } &#x3D; options.poll.options;
            _pollOptions &#x3D; {
                type: &#x27;poll_creation&#x27;,
                pollName: pollName,
                pollOptions: pollOptions,
                pollSelectableOptionsCount: allowMultipleAnswers ? 0 : 1,
                messageSecret:
                Array.isArray(messageSecret) &amp;amp;&amp;amp; messageSecret.length &#x3D;&#x3D;&#x3D; 32
                    ? new Uint8Array(messageSecret)
                    : window.crypto.getRandomValues(new Uint8Array(32))
            };
            delete options.poll;
        }

        let vcardOptions &#x3D; {};
        if (options.contactCard) {
            let contact &#x3D; window.Store.Contact.get(options.contactCard);
            vcardOptions &#x3D; {
                body: window.Store.VCard.vcardFromContactModel(contact).vcard,
                type: &#x27;vcard&#x27;,
                vcardFormattedName: contact.formattedName
            };
            delete options.contactCard;
        } else if (options.contactCardList) {
            let contacts &#x3D; options.contactCardList.map(c &#x3D;&gt; window.Store.Contact.get(c));
            let vcards &#x3D; contacts.map(c &#x3D;&gt; window.Store.VCard.vcardFromContactModel(c));
            vcardOptions &#x3D; {
                type: &#x27;multi_vcard&#x27;,
                vcardList: vcards,
                body: undefined
            };
            delete options.contactCardList;
        } else if (options.parseVCards &amp;amp;&amp;amp; typeof (content) &#x3D;&#x3D;&#x3D; &#x27;string&#x27; &amp;amp;&amp;amp; content.startsWith(&#x27;BEGIN:VCARD&#x27;)) {
            delete options.parseVCards;
            try {
                const parsed &#x3D; window.Store.VCard.parseVcard(content);
                if (parsed) {
                    vcardOptions &#x3D; {
                        type: &#x27;vcard&#x27;,
                        vcardFormattedName: window.Store.VCard.vcardGetNameFromParsed(parsed)
                    };
                }
            } catch (_) {
                // not a vcard
            }
        }

        if (options.linkPreview) {
            delete options.linkPreview;
            const link &#x3D; window.Store.Validators.findLink(content);
            if (link) {
                let preview &#x3D; await window.Store.LinkPreview.getLinkPreview(link);
                if (preview &amp;amp;&amp;amp; preview.data) {
                    preview &#x3D; preview.data;
                    preview.preview &#x3D; true;
                    preview.subtype &#x3D; &#x27;url&#x27;;
                    options &#x3D; {...options, ...preview};
                }
            }
        }
        
        let buttonOptions &#x3D; {};
        if(options.buttons){
            let caption;
            if (options.buttons.type &#x3D;&#x3D;&#x3D; &#x27;chat&#x27;) {
                content &#x3D; options.buttons.body;
                caption &#x3D; content;
            } else {
                caption &#x3D; options.caption ? options.caption : &#x27; &#x27;; //Caption can&#x27;t be empty
            }
            buttonOptions &#x3D; {
                productHeaderImageRejected: false,
                isFromTemplate: false,
                isDynamicReplyButtonsMsg: true,
                title: options.buttons.title ? options.buttons.title : undefined,
                footer: options.buttons.footer ? options.buttons.footer : undefined,
                dynamicReplyButtons: options.buttons.buttons,
                replyButtons: options.buttons.buttons,
                caption: caption
            };
            delete options.buttons;
        }

        let listOptions &#x3D; {};
        if (options.list) {
            if (window.Store.Conn.platform &#x3D;&#x3D;&#x3D; &#x27;smba&#x27; || window.Store.Conn.platform &#x3D;&#x3D;&#x3D; &#x27;smbi&#x27;) {
                throw &#x27;[LT01] Whatsapp business can\&#x27;t send this yet&#x27;;
            }
            listOptions &#x3D; {
                type: &#x27;list&#x27;,
                footer: options.list.footer,
                list: {
                    ...options.list,
                    listType: 1
                },
                body: options.list.description
            };
            delete options.list;
            delete listOptions.list.footer;
        }

        const botOptions &#x3D; {};
        if (options.invokedBotWid) {
            botOptions.messageSecret &#x3D; window.crypto.getRandomValues(new Uint8Array(32));
            botOptions.botMessageSecret &#x3D; await window.Store.BotSecret.genBotMsgSecretFromMsgSecret(botOptions.messageSecret);
            botOptions.invokedBotWid &#x3D; window.Store.WidFactory.createWid(options.invokedBotWid);
            botOptions.botPersonaId &#x3D; window.Store.BotProfiles.BotProfileCollection.get(options.invokedBotWid).personaId;
            delete options.invokedBotWid;
        }

        const meUser &#x3D; window.Store.User.getMaybeMeUser();
        const newId &#x3D; await window.Store.MsgKey.newId();
        
        const newMsgId &#x3D; new window.Store.MsgKey({
            from: meUser,
            to: chat.id,
            id: newId,
            participant: chat.id.isGroup() ? meUser : undefined,
            selfDir: &#x27;out&#x27;,
        });

        const extraOptions &#x3D; options.extraOptions || {};
        delete options.extraOptions;

        const ephemeralFields &#x3D; window.Store.EphemeralFields.getEphemeralFields(chat);

        const message &#x3D; {
            ...options,
            id: newMsgId,
            ack: 0,
            body: content,
            from: meUser,
            to: chat.id,
            local: true,
            self: &#x27;out&#x27;,
            t: parseInt(new Date().getTime() / 1000),
            isNewMsg: true,
            type: &#x27;chat&#x27;,
            ...ephemeralFields,
            ...locationOptions,
            ..._pollOptions,
            ...attOptions,
            ...(attOptions.toJSON ? attOptions.toJSON() : {}),
            ...quotedMsgOptions,
            ...vcardOptions,
            ...buttonOptions,
            ...listOptions,
            ...botOptions,
            ...extraOptions
        };
        
        // Bot&#x27;s won&#x27;t reply if canonicalUrl is set (linking)
        if (botOptions) {
            delete message.canonicalUrl;
        }

        await window.Store.SendMessage.addAndSendMsgToChat(chat, message);
        return window.Store.Msg.get(newMsgId._serialized);
    };
	
    window.WWebJS.editMessage &#x3D; async (msg, content, options &#x3D; {}) &#x3D;&gt; {

        const extraOptions &#x3D; options.extraOptions || {};
        delete options.extraOptions;
        
        if (options.mentionedJidList) {
            options.mentionedJidList &#x3D; await Promise.all(
                options.mentionedJidList.map(async (id) &#x3D;&gt; {
                    const wid &#x3D; window.Store.WidFactory.createWid(id);
                    if (await window.Store.QueryExist(wid)) {
                        return wid;
                    }
                })
            );
            options.mentionedJidList &#x3D; options.mentionedJidList.filter(Boolean);
        }

        if (options.groupMentions) {
            options.groupMentions &#x3D; options.groupMentions.map((e) &#x3D;&gt; ({
                groupSubject: e.subject,
                groupJid: window.Store.WidFactory.createWid(e.id)
            }));
        }

        if (options.linkPreview) {
            delete options.linkPreview;
            const link &#x3D; window.Store.Validators.findLink(content);
            if (link) {
                const preview &#x3D; await window.Store.LinkPreview.getLinkPreview(link);
                preview.preview &#x3D; true;
                preview.subtype &#x3D; &#x27;url&#x27;;
                options &#x3D; { ...options, ...preview };
            }
        }


        const internalOptions &#x3D; {
            ...options,
            ...extraOptions
        };

        await window.Store.EditMessage.sendMessageEdit(msg, content, internalOptions);
        return window.Store.Msg.get(msg.id._serialized);
    };

    window.WWebJS.toStickerData &#x3D; async (mediaInfo) &#x3D;&gt; {
        if (mediaInfo.mimetype &#x3D;&#x3D; &#x27;image/webp&#x27;) return mediaInfo;

        const file &#x3D; window.WWebJS.mediaInfoToFile(mediaInfo);
        const webpSticker &#x3D; await window.Store.StickerTools.toWebpSticker(file);
        const webpBuffer &#x3D; await webpSticker.arrayBuffer();
        const data &#x3D; window.WWebJS.arrayBufferToBase64(webpBuffer);

        return {
            mimetype: &#x27;image/webp&#x27;,
            data
        };
    };

    window.WWebJS.processStickerData &#x3D; async (mediaInfo) &#x3D;&gt; {
        if (mediaInfo.mimetype !&#x3D;&#x3D; &#x27;image/webp&#x27;) throw new Error(&#x27;Invalid media type&#x27;);

        const file &#x3D; window.WWebJS.mediaInfoToFile(mediaInfo);
        let filehash &#x3D; await window.WWebJS.getFileHash(file);
        let mediaKey &#x3D; await window.WWebJS.generateHash(32);

        const controller &#x3D; new AbortController();
        const uploadedInfo &#x3D; await window.Store.UploadUtils.encryptAndUpload({
            blob: file,
            type: &#x27;sticker&#x27;,
            signal: controller.signal,
            mediaKey
        });

        const stickerInfo &#x3D; {
            ...uploadedInfo,
            clientUrl: uploadedInfo.url,
            deprecatedMms3Url: uploadedInfo.url,
            uploadhash: uploadedInfo.encFilehash,
            size: file.size,
            type: &#x27;sticker&#x27;,
            filehash
        };

        return stickerInfo;
    };

    window.WWebJS.processMediaData &#x3D; async (mediaInfo, { forceVoice, forceDocument, forceGif }) &#x3D;&gt; {
        const file &#x3D; window.WWebJS.mediaInfoToFile(mediaInfo);
        const mData &#x3D; await window.Store.OpaqueData.createFromData(file, file.type);
        const mediaPrep &#x3D; window.Store.MediaPrep.prepRawMedia(mData, { asDocument: forceDocument });
        const mediaData &#x3D; await mediaPrep.waitForPrep();
        const mediaObject &#x3D; window.Store.MediaObject.getOrCreateMediaObject(mediaData.filehash);

        const mediaType &#x3D; window.Store.MediaTypes.msgToMediaType({
            type: mediaData.type,
            isGif: mediaData.isGif
        });

        if (forceVoice &amp;amp;&amp;amp; mediaData.type &#x3D;&#x3D;&#x3D; &#x27;audio&#x27;) {
            mediaData.type &#x3D; &#x27;ptt&#x27;;
            const waveform &#x3D; mediaObject.contentInfo.waveform;
            mediaData.waveform &#x3D;
                waveform ?? await window.WWebJS.generateWaveform(file);
        }

        if (forceGif &amp;amp;&amp;amp; mediaData.type &#x3D;&#x3D;&#x3D; &#x27;video&#x27;) {
            mediaData.isGif &#x3D; true;
        }

        if (forceDocument) {
            mediaData.type &#x3D; &#x27;document&#x27;;
        }

        if (!(mediaData.mediaBlob instanceof window.Store.OpaqueData)) {
            mediaData.mediaBlob &#x3D; await window.Store.OpaqueData.createFromData(mediaData.mediaBlob, mediaData.mediaBlob.type);
        }

        mediaData.renderableUrl &#x3D; mediaData.mediaBlob.url();
        mediaObject.consolidate(mediaData.toJSON());
        mediaData.mediaBlob.autorelease();

        const uploadedMedia &#x3D; await window.Store.MediaUpload.uploadMedia({
            mimetype: mediaData.mimetype,
            mediaObject,
            mediaType
        });

        const mediaEntry &#x3D; uploadedMedia.mediaEntry;
        if (!mediaEntry) {
            throw new Error(&#x27;upload failed: media entry was not created&#x27;);
        }

        mediaData.set({
            clientUrl: mediaEntry.mmsUrl,
            deprecatedMms3Url: mediaEntry.deprecatedMms3Url,
            directPath: mediaEntry.directPath,
            mediaKey: mediaEntry.mediaKey,
            mediaKeyTimestamp: mediaEntry.mediaKeyTimestamp,
            filehash: mediaObject.filehash,
            encFilehash: mediaEntry.encFilehash,
            uploadhash: mediaEntry.uploadHash,
            size: mediaObject.size,
            streamingSidecar: mediaEntry.sidecar,
            firstFrameSidecar: mediaEntry.firstFrameSidecar
        });

        return mediaData;
    };

    window.WWebJS.getMessageModel &#x3D; message &#x3D;&gt; {
        const msg &#x3D; message.serialize();

        msg.isEphemeral &#x3D; message.isEphemeral;
        msg.isStatusV3 &#x3D; message.isStatusV3;
        msg.links &#x3D; (window.Store.Validators.findLinks(message.mediaObject ? message.caption : message.body)).map((link) &#x3D;&gt; ({
            link: link.href,
            isSuspicious: Boolean(link.suspiciousCharacters &amp;amp;&amp;amp; link.suspiciousCharacters.size)
        }));

        if (msg.buttons) {
            msg.buttons &#x3D; msg.buttons.serialize();
        }
        if (msg.dynamicReplyButtons) {
            msg.dynamicReplyButtons &#x3D; JSON.parse(JSON.stringify(msg.dynamicReplyButtons));
        }
        if (msg.replyButtons) {
            msg.replyButtons &#x3D; JSON.parse(JSON.stringify(msg.replyButtons));
        }

        if (typeof msg.id.remote &#x3D;&#x3D;&#x3D; &#x27;object&#x27;) {
            msg.id &#x3D; Object.assign({}, msg.id, { remote: msg.id.remote._serialized });
        }

        delete msg.pendingAckUpdate;

        return msg;
    };

    window.WWebJS.getPollVoteModel &#x3D; async (vote) &#x3D;&gt; {
        const _vote &#x3D; vote.serialize();
        if (!vote.parentMsgKey) return null;
        const msg &#x3D;
            window.Store.Msg.get(vote.parentMsgKey) || (await window.Store.Msg.getMessagesById([vote.parentMsgKey]))?.messages?.[0];
        msg &amp;amp;&amp;amp; (_vote.parentMessage &#x3D; window.WWebJS.getMessageModel(msg));
        return _vote;
    };

    window.WWebJS.getChatModel &#x3D; async chat &#x3D;&gt; {

        let res &#x3D; chat.serialize();
        res.isGroup &#x3D; chat.isGroup;
        res.formattedTitle &#x3D; chat.formattedTitle;
        res.isMuted &#x3D; chat.mute &amp;amp;&amp;amp; chat.mute.isMuted;

        if (chat.groupMetadata) {
            const chatWid &#x3D; window.Store.WidFactory.createWid((chat.id._serialized));
            await window.Store.GroupMetadata.update(chatWid);
            res.groupMetadata &#x3D; chat.groupMetadata.serialize();
        }
        
        res.lastMessage &#x3D; null;
        if (res.msgs &amp;amp;&amp;amp; res.msgs.length) {
            const lastMessage &#x3D; chat.lastReceivedKey
                ? window.Store.Msg.get(chat.lastReceivedKey._serialized) || (await window.Store.Msg.getMessagesById([chat.lastReceivedKey._serialized]))?.messages?.[0]
                : null;
            if (lastMessage) {
                res.lastMessage &#x3D; window.WWebJS.getMessageModel(lastMessage);
            }
        }
        
        delete res.msgs;
        delete res.msgUnsyncedButtonReplyMsgs;
        delete res.unsyncedButtonReplies;

        return res;
    };

    window.WWebJS.getChat &#x3D; async chatId &#x3D;&gt; {
        const chatWid &#x3D; window.Store.WidFactory.createWid(chatId);
        const chat &#x3D; await window.Store.Chat.find(chatWid);
        return await window.WWebJS.getChatModel(chat);
    };

    window.WWebJS.getChats &#x3D; async () &#x3D;&gt; {
        const chats &#x3D; window.Store.Chat.getModelsArray();

        const chatPromises &#x3D; chats.map(chat &#x3D;&gt; window.WWebJS.getChatModel(chat));
        return await Promise.all(chatPromises);
    };

    window.WWebJS.getContactModel &#x3D; contact &#x3D;&gt; {
        let res &#x3D; contact.serialize();
        res.isBusiness &#x3D; contact.isBusiness &#x3D;&#x3D;&#x3D; undefined ? false : contact.isBusiness;

        if (contact.businessProfile) {
            res.businessProfile &#x3D; contact.businessProfile.serialize();
        }

        // TODO: remove useOldImplementation and its checks once all clients are updated to &gt;&#x3D; v2.2327.4
        const useOldImplementation
            &#x3D; window.compareWwebVersions(window.Debug.VERSION, &#x27;&amp;lt;&#x27;, &#x27;2.2327.4&#x27;);

        res.isMe &#x3D; useOldImplementation
            ? contact.isMe
            : window.Store.ContactMethods.getIsMe(contact);
        res.isUser &#x3D; useOldImplementation
            ? contact.isUser
            : window.Store.ContactMethods.getIsUser(contact);
        res.isGroup &#x3D; useOldImplementation
            ? contact.isGroup
            : window.Store.ContactMethods.getIsGroup(contact);
        res.isWAContact &#x3D; useOldImplementation
            ? contact.isWAContact
            : window.Store.ContactMethods.getIsWAContact(contact);
        res.isMyContact &#x3D; useOldImplementation
            ? contact.isMyContact
            : window.Store.ContactMethods.getIsMyContact(contact);
        res.isBlocked &#x3D; contact.isContactBlocked;
        res.userid &#x3D; useOldImplementation
            ? contact.userid
            : window.Store.ContactMethods.getUserid(contact);
        res.isEnterprise &#x3D; useOldImplementation
            ? contact.isEnterprise
            : window.Store.ContactMethods.getIsEnterprise(contact);
        res.verifiedName &#x3D; useOldImplementation
            ? contact.verifiedName
            : window.Store.ContactMethods.getVerifiedName(contact);
        res.verifiedLevel &#x3D; useOldImplementation
            ? contact.verifiedLevel
            : window.Store.ContactMethods.getVerifiedLevel(contact);
        res.statusMute &#x3D; useOldImplementation
            ? contact.statusMute
            : window.Store.ContactMethods.getStatusMute(contact);
        res.name &#x3D; useOldImplementation
            ? contact.name
            : window.Store.ContactMethods.getName(contact);
        res.shortName &#x3D; useOldImplementation
            ? contact.shortName
            : window.Store.ContactMethods.getShortName(contact);
        res.pushname &#x3D; useOldImplementation
            ? contact.pushname
            : window.Store.ContactMethods.getPushname(contact);

        return res;
    };

    window.WWebJS.getContact &#x3D; async contactId &#x3D;&gt; {
        const wid &#x3D; window.Store.WidFactory.createWid(contactId);
        const contact &#x3D; await window.Store.Contact.find(wid);
        const bizProfile &#x3D; await window.Store.BusinessProfile.fetchBizProfile(wid);
        bizProfile.profileOptions &amp;amp;&amp;amp; (contact.businessProfile &#x3D; bizProfile);
        return window.WWebJS.getContactModel(contact);
    };

    window.WWebJS.getContacts &#x3D; () &#x3D;&gt; {
        const contacts &#x3D; window.Store.Contact.getModelsArray();
        return contacts.map(contact &#x3D;&gt; window.WWebJS.getContactModel(contact));
    };

    window.WWebJS.mediaInfoToFile &#x3D; ({ data, mimetype, filename }) &#x3D;&gt; {
        const binaryData &#x3D; window.atob(data);

        const buffer &#x3D; new ArrayBuffer(binaryData.length);
        const view &#x3D; new Uint8Array(buffer);
        for (let i &#x3D; 0; i &amp;lt; binaryData.length; i++) {
            view[i] &#x3D; binaryData.charCodeAt(i);
        }

        const blob &#x3D; new Blob([buffer], { type: mimetype });
        return new File([blob], filename, {
            type: mimetype,
            lastModified: Date.now()
        });
    };

    window.WWebJS.arrayBufferToBase64 &#x3D; (arrayBuffer) &#x3D;&gt; {
        let binary &#x3D; &#x27;&#x27;;
        const bytes &#x3D; new Uint8Array(arrayBuffer);
        const len &#x3D; bytes.byteLength;
        for (let i &#x3D; 0; i &amp;lt; len; i++) {
            binary +&#x3D; String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    };

    window.WWebJS.arrayBufferToBase64Async &#x3D; (arrayBuffer) &#x3D;&gt;
        new Promise((resolve, reject) &#x3D;&gt; {
            const blob &#x3D; new Blob([arrayBuffer], {
                type: &#x27;application/octet-stream&#x27;,
            });
            const fileReader &#x3D; new FileReader();
            fileReader.onload &#x3D; () &#x3D;&gt; {
                const [, data] &#x3D; fileReader.result.split(&#x27;,&#x27;);
                resolve(data);
            };
            fileReader.onerror &#x3D; (e) &#x3D;&gt; reject(e);
            fileReader.readAsDataURL(blob);
        });

    window.WWebJS.getFileHash &#x3D; async (data) &#x3D;&gt; {
        let buffer &#x3D; await data.arrayBuffer();
        const hashBuffer &#x3D; await crypto.subtle.digest(&#x27;SHA-256&#x27;, buffer);
        return btoa(String.fromCharCode(...new Uint8Array(hashBuffer)));
    };

    window.WWebJS.generateHash &#x3D; async (length) &#x3D;&gt; {
        var result &#x3D; &#x27;&#x27;;
        var characters &#x3D; &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#x27;;
        var charactersLength &#x3D; characters.length;
        for (var i &#x3D; 0; i &amp;lt; length; i++) {
            result +&#x3D; characters.charAt(Math.floor(Math.random() * charactersLength));
        }
        return result;
    };

    /**
     * Referenced from and modified:
     * @see https://github.com/wppconnect-team/wa-js/commit/290ebfefe6021b3d17f7fdfdda5545bb0473b26f
     */
    window.WWebJS.generateWaveform &#x3D; async (audioFile) &#x3D;&gt; {
        try {
            const audioData &#x3D; await audioFile.arrayBuffer();
            const audioContext &#x3D; new AudioContext();
            const audioBuffer &#x3D; await audioContext.decodeAudioData(audioData);

            const rawData &#x3D; audioBuffer.getChannelData(0);
            const samples &#x3D; 64;
            const blockSize &#x3D; Math.floor(rawData.length / samples);
            const filteredData &#x3D; [];
            for (let i &#x3D; 0; i &amp;lt; samples; i++) {
                const blockStart &#x3D; blockSize * i;
                let sum &#x3D; 0;
                for (let j &#x3D; 0; j &amp;lt; blockSize; j++) {
                    sum &#x3D; sum + Math.abs(rawData[blockStart + j]);
                }
                filteredData.push(sum / blockSize);
            }

            const multiplier &#x3D; Math.pow(Math.max(...filteredData), -1);
            const normalizedData &#x3D; filteredData.map((n) &#x3D;&gt; n * multiplier);

            const waveform &#x3D; new Uint8Array(
                normalizedData.map((n) &#x3D;&gt; Math.floor(100 * n))
            );

            return waveform;
        } catch (e) {
            return undefined;
        }
    };

    window.WWebJS.sendClearChat &#x3D; async (chatId) &#x3D;&gt; {
        let chat &#x3D; window.Store.Chat.get(chatId);
        if (chat !&#x3D;&#x3D; undefined) {
            await window.Store.SendClear.sendClear(chat, false);
            return true;
        }
        return false;
    };

    window.WWebJS.sendDeleteChat &#x3D; async (chatId) &#x3D;&gt; {
        let chat &#x3D; window.Store.Chat.get(chatId);
        if (chat !&#x3D;&#x3D; undefined) {
            await window.Store.SendDelete.sendDelete(chat);
            return true;
        }
        return false;
    };

    window.WWebJS.sendChatstate &#x3D; async (state, chatId) &#x3D;&gt; {
        chatId &#x3D; window.Store.WidFactory.createWid(chatId);

        switch (state) {
        case &#x27;typing&#x27;:
            await window.Store.ChatState.sendChatStateComposing(chatId);
            break;
        case &#x27;recording&#x27;:
            await window.Store.ChatState.sendChatStateRecording(chatId);
            break;
        case &#x27;stop&#x27;:
            await window.Store.ChatState.sendChatStatePaused(chatId);
            break;
        default:
            throw &#x27;Invalid chatstate&#x27;;
        }

        return true;
    };

    window.WWebJS.getLabelModel &#x3D; label &#x3D;&gt; {
        let res &#x3D; label.serialize();
        res.hexColor &#x3D; label.hexColor;

        return res;
    };

    window.WWebJS.getLabels &#x3D; () &#x3D;&gt; {
        const labels &#x3D; window.Store.Label.getModelsArray();
        return labels.map(label &#x3D;&gt; window.WWebJS.getLabelModel(label));
    };

    window.WWebJS.getLabel &#x3D; (labelId) &#x3D;&gt; {
        const label &#x3D; window.Store.Label.get(labelId);
        return window.WWebJS.getLabelModel(label);
    };

    window.WWebJS.getChatLabels &#x3D; async (chatId) &#x3D;&gt; {
        const chat &#x3D; await window.WWebJS.getChat(chatId);
        return (chat.labels || []).map(id &#x3D;&gt; window.WWebJS.getLabel(id));
    };

    window.WWebJS.getOrderDetail &#x3D; async (orderId, token, chatId) &#x3D;&gt; {
        const chatWid &#x3D; window.Store.WidFactory.createWid(chatId);
        return window.Store.QueryOrder.queryOrder(chatWid, orderId, 80, 80, token);
    };

    window.WWebJS.getProductMetadata &#x3D; async (productId) &#x3D;&gt; {
        let sellerId &#x3D; window.Store.Conn.wid;
        let product &#x3D; await window.Store.QueryProduct.queryProduct(sellerId, productId);
        if (product &amp;amp;&amp;amp; product.data) {
            return product.data;
        }

        return undefined;
    };

    window.WWebJS.rejectCall &#x3D; async (peerJid, id) &#x3D;&gt; {
        peerJid &#x3D; peerJid.split(&#x27;@&#x27;)[0] + &#x27;@s.whatsapp.net&#x27;;
        let userId &#x3D; window.Store.User.getMaybeMeUser().user + &#x27;@s.whatsapp.net&#x27;;
        const stanza &#x3D; window.Store.SocketWap.wap(&#x27;call&#x27;, {
            id: window.Store.SocketWap.generateId(),
            from: window.Store.SocketWap.USER_JID(userId),
            to: window.Store.SocketWap.USER_JID(peerJid),
        }, [
            window.Store.SocketWap.wap(&#x27;reject&#x27;, {
                &#x27;call-id&#x27;: id,
                &#x27;call-creator&#x27;: window.Store.SocketWap.USER_JID(peerJid),
                count: &#x27;0&#x27;,
            })
        ]);
        await window.Store.Socket.deprecatedCastStanza(stanza);
    };

    window.WWebJS.cropAndResizeImage &#x3D; async (media, options &#x3D; {}) &#x3D;&gt; {
        if (!media.mimetype.includes(&#x27;image&#x27;))
            throw new Error(&#x27;Media is not an image&#x27;);

        if (options.mimetype &amp;amp;&amp;amp; !options.mimetype.includes(&#x27;image&#x27;))
            delete options.mimetype;

        options &#x3D; Object.assign({ size: 640, mimetype: media.mimetype, quality: .75, asDataUrl: false }, options);

        const img &#x3D; await new Promise ((resolve, reject) &#x3D;&gt; {
            const img &#x3D; new Image();
            img.onload &#x3D; () &#x3D;&gt; resolve(img);
            img.onerror &#x3D; reject;
            img.src &#x3D; &#x60;data:${media.mimetype};base64,${media.data}&#x60;;
        });

        const sl &#x3D; Math.min(img.width, img.height);
        const sx &#x3D; Math.floor((img.width - sl) / 2);
        const sy &#x3D; Math.floor((img.height - sl) / 2);

        const canvas &#x3D; document.createElement(&#x27;canvas&#x27;);
        canvas.width &#x3D; options.size;
        canvas.height &#x3D; options.size;

        const ctx &#x3D; canvas.getContext(&#x27;2d&#x27;);
        ctx.drawImage(img, sx, sy, sl, sl, 0, 0, options.size, options.size);

        const dataUrl &#x3D; canvas.toDataURL(options.mimetype, options.quality);

        if (options.asDataUrl)
            return dataUrl;

        return Object.assign(media, {
            mimetype: options.mimeType,
            data: dataUrl.replace(&#x60;data:${options.mimeType};base64,&#x60;, &#x27;&#x27;)
        });
    };

    window.WWebJS.setPicture &#x3D; async (chatid, media) &#x3D;&gt; {
        const thumbnail &#x3D; await window.WWebJS.cropAndResizeImage(media, { asDataUrl: true, mimetype: &#x27;image/jpeg&#x27;, size: 96 });
        const profilePic &#x3D; await window.WWebJS.cropAndResizeImage(media, { asDataUrl: true, mimetype: &#x27;image/jpeg&#x27;, size: 640 });

        const chatWid &#x3D; window.Store.WidFactory.createWid(chatid);
        try {
            const collection &#x3D; window.Store.ProfilePicThumb.get(chatid);
            if (!collection.canSet()) return;

            const res &#x3D; await window.Store.GroupUtils.sendSetPicture(chatWid, thumbnail, profilePic);
            return res ? res.status &#x3D;&#x3D;&#x3D; 200 : false;
        } catch (err) {
            if(err.name &#x3D;&#x3D;&#x3D; &#x27;ServerStatusCodeError&#x27;) return false;
            throw err;
        }
    };

    window.WWebJS.deletePicture &#x3D; async (chatid) &#x3D;&gt; {
        const chatWid &#x3D; window.Store.WidFactory.createWid(chatid);
        try {
            const collection &#x3D; window.Store.ProfilePicThumb.get(chatid);
            if (!collection.canDelete()) return;

            const res &#x3D; await window.Store.GroupUtils.requestDeletePicture(chatWid);
            return res ? res.status &#x3D;&#x3D;&#x3D; 200 : false;
        } catch (err) {
            if(err.name &#x3D;&#x3D;&#x3D; &#x27;ServerStatusCodeError&#x27;) return false;
            throw err;
        }
    };
    
    window.WWebJS.getProfilePicThumbToBase64 &#x3D; async (chatWid) &#x3D;&gt; {
        const profilePicCollection &#x3D; await window.Store.ProfilePicThumb.find(chatWid);

        const _readImageAsBase64 &#x3D; (imageBlob) &#x3D;&gt; {
            return new Promise((resolve) &#x3D;&gt; {
                const reader &#x3D; new FileReader();
                reader.onloadend &#x3D; function () {
                    const base64Image &#x3D; reader.result;
                    if (base64Image &#x3D;&#x3D; null) {
                        resolve(undefined);
                    } else {
                        const base64Data &#x3D; base64Image.toString().split(&#x27;,&#x27;)[1];
                        resolve(base64Data);
                    }
                };
                reader.readAsDataURL(imageBlob);
            });
        };

        if (profilePicCollection?.img) {
            try {
                const response &#x3D; await fetch(profilePicCollection.img);
                if (response.ok) {
                    const imageBlob &#x3D; await response.blob();
                    if (imageBlob) {
                        const base64Image &#x3D; await _readImageAsBase64(imageBlob);
                        return base64Image;
                    }
                }
            } catch (error) { /* empty */ }
        }
        return undefined;
    };

    window.WWebJS.getAddParticipantsRpcResult &#x3D; async (groupMetadata, groupWid, participantWid) &#x3D;&gt; {
        const participantLidArgs &#x3D; groupMetadata?.isLidAddressingMode
            ? {
                phoneNumber: participantWid,
                lid: window.Store.LidUtils.getCurrentLid(participantWid)
            }
            : { phoneNumber: participantWid };

        const iqTo &#x3D; window.Store.WidToJid.widToGroupJid(groupWid);

        const participantArgs &#x3D;
            participantLidArgs.lid
                ? [{
                    participantJid: window.Store.WidToJid.widToUserJid(participantLidArgs.lid),
                    phoneNumberMixinArgs: {
                        anyPhoneNumber: window.Store.WidToJid.widToUserJid(participantLidArgs.phoneNumber)
                    }
                }]
                : [{
                    participantJid: window.Store.WidToJid.widToUserJid(participantLidArgs.phoneNumber)
                }];

        let rpcResult, resultArgs;
        const isOldImpl &#x3D; window.compareWwebVersions(window.Debug.VERSION, &#x27;&amp;lt;&#x3D;&#x27;, &#x27;2.2335.9&#x27;);
        const data &#x3D; {
            name: undefined,
            code: undefined,
            inviteV4Code: undefined,
            inviteV4CodeExp: undefined
        };

        try {
            rpcResult &#x3D; await window.Store.GroupParticipants.sendAddParticipantsRPC({ participantArgs, iqTo });
            resultArgs &#x3D; isOldImpl
                ? rpcResult.value.addParticipant[0].addParticipantsParticipantMixins
                : rpcResult.value.addParticipant[0]
                    .addParticipantsParticipantAddedOrNonRegisteredWaUserParticipantErrorLidResponseMixinGroup
                    .value
                    .addParticipantsParticipantMixins;
        } catch (err) {
            data.code &#x3D; 400;
            return data;
        }

        if (rpcResult.name &#x3D;&#x3D;&#x3D; &#x27;AddParticipantsResponseSuccess&#x27;) {
            const code &#x3D; resultArgs?.value.error ?? &#x27;200&#x27;;
            data.name &#x3D; resultArgs?.name;
            data.code &#x3D; +code;
            data.inviteV4Code &#x3D; resultArgs?.value.addRequestCode;
            data.inviteV4CodeExp &#x3D; resultArgs?.value.addRequestExpiration?.toString();
        }

        else if (rpcResult.name &#x3D;&#x3D;&#x3D; &#x27;AddParticipantsResponseClientError&#x27;) {
            const { code: code } &#x3D; rpcResult.value.errorAddParticipantsClientErrors.value;
            data.code &#x3D; +code;
        }

        else if (rpcResult.name &#x3D;&#x3D;&#x3D; &#x27;AddParticipantsResponseServerError&#x27;) {
            const { code: code } &#x3D; rpcResult.value.errorServerErrors.value;
            data.code &#x3D; +code;
        }

        return data;
    };

    window.WWebJS.membershipRequestAction &#x3D; async (groupId, action, requesterIds, sleep) &#x3D;&gt; {
        const groupWid &#x3D; window.Store.WidFactory.createWid(groupId);
        const group &#x3D; await window.Store.Chat.find(groupWid);
        const toApprove &#x3D; action &#x3D;&#x3D;&#x3D; &#x27;Approve&#x27;;
        let membershipRequests;
        let response;
        let result &#x3D; [];

        await window.Store.GroupQueryAndUpdate(groupWid);

        if (!requesterIds?.length) {
            membershipRequests &#x3D; group.groupMetadata.membershipApprovalRequests._models.map(({ id }) &#x3D;&gt; id);
        } else {
            !Array.isArray(requesterIds) &amp;amp;&amp;amp; (requesterIds &#x3D; [requesterIds]);
            membershipRequests &#x3D; requesterIds.map(r &#x3D;&gt; window.Store.WidFactory.createWid(r));
        }

        if (!membershipRequests.length) return [];

        const participantArgs &#x3D; membershipRequests.map(m &#x3D;&gt; ({
            participantArgs: [
                {
                    participantJid: window.Store.WidToJid.widToUserJid(m)
                }
            ]
        }));

        const groupJid &#x3D; window.Store.WidToJid.widToGroupJid(groupWid);
        
        const _getSleepTime &#x3D; (sleep) &#x3D;&gt; {
            if (!Array.isArray(sleep) || (sleep.length &#x3D;&#x3D;&#x3D; 2 &amp;amp;&amp;amp; sleep[0] &#x3D;&#x3D;&#x3D; sleep[1])) {
                return sleep;
            }
            if (sleep.length &#x3D;&#x3D;&#x3D; 1) {
                return sleep[0];
            }
            sleep[1] - sleep[0] &amp;lt; 100 &amp;amp;&amp;amp; (sleep[0] &#x3D; sleep[1]) &amp;amp;&amp;amp; (sleep[1] +&#x3D; 100);
            return Math.floor(Math.random() * (sleep[1] - sleep[0] + 1)) + sleep[0];
        };

        const membReqResCodes &#x3D; {
            default: &#x60;An unknown error occupied while ${toApprove ? &#x27;approving&#x27; : &#x27;rejecting&#x27;} the participant membership request&#x60;,
            400: &#x27;ParticipantNotFoundError&#x27;,
            401: &#x27;ParticipantNotAuthorizedError&#x27;,
            403: &#x27;ParticipantForbiddenError&#x27;,
            404: &#x27;ParticipantRequestNotFoundError&#x27;,
            408: &#x27;ParticipantTemporarilyBlockedError&#x27;,
            409: &#x27;ParticipantConflictError&#x27;,
            412: &#x27;ParticipantParentLinkedGroupsResourceConstraintError&#x27;,
            500: &#x27;ParticipantResourceConstraintError&#x27;
        };

        try {
            for (const participant of participantArgs) {
                response &#x3D; await window.Store.MembershipRequestUtils.sendMembershipRequestsActionRPC({
                    iqTo: groupJid,
                    [toApprove ? &#x27;approveArgs&#x27; : &#x27;rejectArgs&#x27;]: participant
                });

                if (response.name &#x3D;&#x3D;&#x3D; &#x27;MembershipRequestsActionResponseSuccess&#x27;) {
                    const value &#x3D; toApprove
                        ? response.value.membershipRequestsActionApprove
                        : response.value.membershipRequestsActionReject;
                    if (value?.participant) {
                        const [_] &#x3D; value.participant.map(p &#x3D;&gt; {
                            const error &#x3D; toApprove
                                ? value.participant[0].membershipRequestsActionAcceptParticipantMixins?.value.error
                                : value.participant[0].membershipRequestsActionRejectParticipantMixins?.value.error;
                            return {
                                requesterId: window.Store.WidFactory.createWid(p.jid)._serialized,
                                ...(error
                                    ? { error: +error, message: membReqResCodes[error] || membReqResCodes.default }
                                    : { message: &#x60;${toApprove ? &#x27;Approved&#x27; : &#x27;Rejected&#x27;} successfully&#x60; })
                            };
                        });
                        _ &amp;amp;&amp;amp; result.push(_);
                    }
                } else {
                    result.push({
                        requesterId: window.Store.JidToWid.userJidToUserWid(participant.participantArgs[0].participantJid)._serialized,
                        message: &#x27;ServerStatusCodeError&#x27;
                    });
                }

                sleep &amp;amp;&amp;amp;
                    participantArgs.length &gt; 1 &amp;amp;&amp;amp;
                    participantArgs.indexOf(participant) !&#x3D;&#x3D; participantArgs.length - 1 &amp;amp;&amp;amp;
                    (await new Promise((resolve) &#x3D;&gt; setTimeout(resolve, _getSleepTime(sleep))));
            }
            return result;
        } catch (err) {
            return [];
        }
    };

    window.WWebJS.pinUnpinMsgAction &#x3D; async (msgId, action, duration) &#x3D;&gt; {
        const message &#x3D; window.Store.Msg.get(msgId) || (await window.Store.Msg.getMessagesById([msgId]))?.messages?.[0];
        if (!message) return false;
        const response &#x3D; await window.Store.pinUnpinMsg(message, action, duration);
        return response.messageSendResult &#x3D;&#x3D;&#x3D; &#x27;OK&#x27;;
    };
    
    window.WWebJS.getStatusModel &#x3D; status &#x3D;&gt; {
        let res &#x3D; status.serialize();
        delete res._msgs;
        res.msgs &#x3D; status._msgs.map(msg &#x3D;&gt; window.WWebJS.getMessageModel(msg));
        return res;
    };

    window.WWebJS.getAllStatuses &#x3D; () &#x3D;&gt; {
        const statuses &#x3D; window.Store.Status.getModelsArray();
        return statuses.map(status &#x3D;&gt; window.WWebJS.getStatusModel(status));
    };
};
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.6.11 on October 4, 2024.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>